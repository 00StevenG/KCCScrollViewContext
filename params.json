{"name":"KCCScrollViewContext","tagline":"","body":"#Scrolling with context\r\n\r\nUIScrollView is an indispensable class for iOS development. If you're not using UIScrollView, you're likely using one of it's subclasses (such as UITableView, UICollectionView or UITextView) and implementing its delegate protocol (UIScrollViewDelegate) or extended delegates (such as UITableViewDelegate or  UITextViewDelegate). I often implement methods to calculate UIScrollView state or position. The logical place is the view controller instance presenting the scroll view. It may look something like this:\r\n\r\n```\r\n@interface ViewControlller \r\n\r\n// scrolling state\r\n@property (nonatomic, readwrtie, asssign) BOOL isScrolling;\r\n\r\n@end \r\n```\r\n\r\nRather than do this again and again (see [DRY](https://en.wikipedia.org/wiki/Don't_repeat_yourself)) ), I’ve created KCCScrollViewContext.\r\n\r\nKCCScrollViewContext provides additional UIScrollView state and expands upon UIScrollViewDelegate. It’s simple to add and works with existing messaging from UIScrollViewDelegate and its extended protocols. It features :\r\n\r\n* accessors like isScrolling, isAnimating, and current scrolling direction (UIRectEdge) \r\n* accessors to contentOffset values during scrolling events (scrollingBeganOffset , expectedScrollingEndOffset, scrollingEndedOffset) \r\n* additional delegate callbacks with content offsets for ‘will scroll’ (calculated)  and ‘did scroll’ (actual),  \r\n* additional delegate callbacks for ‘will scroll’ and ‘did scroll’ events with content edge detection (UIRectEdge) and scrollview bounce events. \r\n* completion block handlers for UIScrollView’s built in animated methods (setContentOffset:animated: / scrollRectToVisible:animated:) \r\n* additional zooming callbacks when the user initiates zooming at and past the minimum or maximum zoom scale. \r\n* UIScrollViewDelegate and it’s extended protocols (UITableViewDelegate and so on) methods are forwarded to the original delegate (such as UITableViewController). \r\n\r\nHow to use:\r\n\r\n```\r\n- (void)viewDidLoad {\r\n    [super viewDidLoad];    \r\n    self.scrollContext = [[KCCScrollViewContext alloc]initWithScrollView:self.tableView andDelegate:self];\r\n}\r\n```\r\n\r\nInit:\r\n\r\nKCCScrollViewContext servers as the passed UIScrollView instance’s delegate. It also adds an additional handler to scrollView’s pan gesture to keep track of the most recent tracking point.\r\n\r\n```\r\n- (instancetype)initWithScrollView:(UIScrollView*)scrollView andDelegate:(id<KCCScrollViewContextDelegate>)delegate {  \r\n    if ([super init]) {\r\n        _scrollDelegate = delegate;\r\n        _scrollView = scrollView;\r\n        _scrollView.delegate = self;\r\n        _lastContentOffset = _scrollView.contentOffset;\r\n        [_scrollView.panGestureRecognizer addTarget:self action:@selector(scrollViewPanGestureHandler:)];\r\n    }\r\n    return self;\r\n}\r\n```\r\n\r\nMessaging:\r\n\r\nKCCScrollViewContext works with existing delegate instances by using Objective-C’s dyanmic messaging feature. It overrides two NSObject methods\r\n\r\n* respondsToSelector: \r\n* forwardingTargetForSelector: \r\n\r\nWhen the context is reassigned as the delegate. UIScrollView subclasses such as UITableView check which methods the object responds to by calling respondsToSelector. So the context’s implementation of this method checks itself and it’s delegate.\r\n\r\n```\r\n- (BOOL)respondsToSelector:(SEL)aSelector {\r\n    \r\n    BOOL result = [super respondsToSelector:aSelector];\r\n    if (!result) {\r\n        result = [self.scrollDelegate respondsToSelector:aSelector];\r\n    }\r\n    return result;\r\n}\r\n```\r\n\r\nWhen the context is sent a message for a method not implemented (such as in response to UITableView row selection), forwardingTargetForSelector is an opportunity to provide an object that can. In this case the context’s delegate.\r\n\r\n```\r\n- (id)forwardingTargetForSelector:(SEL)aSelector {\r\n \r\n    if ([self.scrollDelegate respondsToSelector:aSelector]) {\r\n        return self.scrollDelegate;\r\n    }\r\n    return [super forwardingTargetForSelector:aSelector];\r\n}\r\n```\r\n\r\nFor UIScrollViewDelegate methods implemented by the context (such as scrollViewDidScroll:). The context first updates it’s internal logic and state and then forwards the original invocation to the delegate as seen here.\r\n\r\n```\r\n- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView {\r\n    \r\n    self.isScrolling = YES;\r\n    [self sendScroll:scrollView messageIfNeeded:_cmd];\r\n}\r\n\r\n- (void)sendScroll:(UIScrollView *)scroll messageIfNeeded:(SEL)message {\r\n    \r\n    if ([self.scrollDelegate respondsToSelector:message]) {\r\n#       pragma clang diagnostic push\r\n#       pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\r\n        [self.scrollDelegate performSelector:message withObject:scroll];\r\n#       pragma clang diagnostic pop\r\n    }\r\n}\r\n```\r\n\r\nThe remainder of the context code is simply calculations and state management by responding to scroll view events.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}